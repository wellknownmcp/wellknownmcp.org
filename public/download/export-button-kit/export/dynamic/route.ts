import { NextResponse } from "next/server"
import * as cheerio from "cheerio"
import TurndownService from "turndown"
import fs from "fs"
import path from "path"
import { recipes } from "@/lib/recipes"
import { cleanDataAttributes } from "@/lib/domUtils";

export const runtime = "nodejs"

export async function POST(req: Request) {
  const { html, dynamicId } = await req.json()
  if (!html || !dynamicId) return NextResponse.json({ error: "Missing html or dynamicId" }, { status: 400 })

  const recipe = recipes.find(r => r.id === dynamicId)
  if (!recipe) return NextResponse.json({ error: "Recipe not found" }, { status: 404 })

  const $ = cheerio.load(html)
$("selector").each((_, el) => {
  cleanDataAttributes(el, $)
})
  $("script, style, meta, link, noscript").remove()
$("*").each((_, el) => {
  $(el).removeAttr("class style id")
  cleanDataAttributes(el, $)
})
  const cleanHtml = $("body").html() ?? html

  const turndownService = new TurndownService()
  const markdown = turndownService.turndown(cleanHtml)

  let blocks: any[] = []

  for (const block of recipe.blocks) {
    try {
      if (block.type === "md") {
        const mdPath = path.resolve("./" + block.value)
        if (fs.existsSync(mdPath)) {
          const content = fs.readFileSync(mdPath, "utf8")
          blocks.push({ block_name: block.block_name, type: "markdown", content })
        }
      } else if (block.type === "file") {
        const filePath = path.resolve("./" + block.value)
        if (fs.existsSync(filePath)) {
          const json = JSON.parse(fs.readFileSync(filePath, "utf8"))
          blocks.push({ block_name: block.block_name, type: "file", content: json })
        }
      } else if (block.type === "url") {
        const res = await fetch(block.value)
        const json = await res.json()
        blocks.push({ block_name: block.block_name, type: "url", content: json })
      }
    } catch (err) {
      console.error("Block load failed for", block, ":", err)
    }
  }

  let feed: any = {
    feed_type: "llmfeed",
    metadata: {
      origin: req.headers.get("host") ? `https://${req.headers.get("host")}` : "",
      source_url: req.headers.get("referer") ?? "",
      title: "Dynamic Export: " + dynamicId,
      description: recipe.context ?? "LLM dynamic export",
      tags: ["mcp", "llmfeed", "dynamic"],
      content_type: "html+markdown+blocks",
      generated_at: new Date().toISOString()
    },
    trust: {
      trust_level: "self-declared",
      certifier: "https://wellknownmcp.org",
      agent_hint: "This feed is generated by wellknownmcp.org dynamic export",
      block_name: "trust disclaimer",
      scope: "partial",
      warning: "This export has not been signed by a certified authority."
    }
  }

  try {
    const templatePath = path.resolve("./data/current-export-signed-template.json")
    if (fs.existsSync(templatePath)) {
      const template = JSON.parse(fs.readFileSync(templatePath, "utf8"))
      const { data, ...restTemplate } = template
      Object.assign(feed, restTemplate)
    }
  } catch (err) {
    console.error("Signed template merge failed:", err)
  }

  feed.data = {
    html: cleanHtml,
    markdown,
    blocks
  }

  return NextResponse.json(feed)
}
